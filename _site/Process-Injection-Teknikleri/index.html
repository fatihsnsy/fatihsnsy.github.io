<!DOCTYPE html> <html lang="tr-TR"> <head prefix="og: http://ogp.me/ns#"> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="ie=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <meta name="mobile-web-app-capable" content="yes" /> <meta name="apple-mobile-web-app-capable" content="yes" /> <meta name="application-name" content="Fatih Şensoy" /> <meta name="apple-mobile-web-app-status-bar-style" content="#fff" /> <meta name="apple-mobile-web-app-title" content="Fatih Şensoy" /> <title> 💉 Process Injection Teknikleri Ve Detayları - Fatih Şensoy </title> <link rel="alternate" href="https://fatihsensoy.com/Process-Injection-Teknikleri/" hreflang="tr-TR" /> <link rel="canonical" href="https://fatihsensoy.com/Process-Injection-Teknikleri/" /> <meta name="description" content="Bir eğitim niteliğinde olan bu makalemizde sizlere Process Injection Tekniklerini olabildiğince detaylı ve açıklayıcı şekilde anlattım." /> <meta name="referrer" content="no-referrer-when-downgrade" /> <meta property="fb:app_id" content="" /> <meta property="og:site_name" content="💉 Process Injection Teknikleri Ve Detayları | " /> <meta property="og:title" content="💉 Process Injection Teknikleri Ve Detayları | " /> <meta property="og:type" content="website" /> <meta property="og:url" content="https://fatihsensoy.com/Process-Injection-Teknikleri/" /> <meta property="og:description" content="Bir eğitim niteliğinde olan bu makalemizde sizlere Process Injection Tekniklerini olabildiğince detaylı ve açıklayıcı şekilde anlattım." /> <meta property="og:image" content="https://fatihsensoy.com/assets/img/process-injection-teknikleri/img/cover.jpg" /> <meta property="og:image:width" content="640" /> <meta property="og:image:height" content="640" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:title" content="💉 Process Injection Teknikleri Ve Detayları | fatihsnsy" /> <meta name="twitter:url" content="https://fatihsensoy.com/Process-Injection-Teknikleri/" /> <meta name="twitter:site" content="@fatihsnsy" /> <meta name="twitter:creator" content="@fatihsnsy" /> <meta name="twitter:description" content="Bir eğitim niteliğinde olan bu makalemizde sizlere Process Injection Tekniklerini olabildiğince detaylı ve açıklayıcı şekilde anlattım." /> <meta name="twitter:image" content="https://fatihsensoy.com/assets/img/process-injection-teknikleri/img/cover.jpg" /> <link type="application/atom+xml" rel="alternate" href="https://fatihsensoy.com/feed.xml" title="Fatih Şensoy" /> <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/fav-32.png" /> <link rel="manifest" href="/assets/favicons/site.webmanifest" /> <meta name="apple-mobile-web-app-title" content="Jekyll Klise" /> <meta name="application-name" content="Jekyll Klise" /> <meta name="msapplication-TileColor" content="#da532c" /> <meta name="theme-color" content="#2c2c2c" /> <link rel="stylesheet" href="/assets/css/style.css" /> <!-- Begin Jekyll SEO tag v2.7.1 --> <title>💉 Process Injection Teknikleri Ve Detayları | Fatih Şensoy</title> <meta name="generator" content="Jekyll v4.1.1" /> <meta property="og:title" content="💉 Process Injection Teknikleri Ve Detayları" /> <meta name="author" content="Fatih ŞENSOY" /> <meta property="og:locale" content="tr_TR" /> <meta name="description" content="Bir eğitim niteliğinde olan bu makalemizde sizlere Process Injection Tekniklerini olabildiğince detaylı ve açıklayıcı şekilde anlattım." /> <meta property="og:description" content="Bir eğitim niteliğinde olan bu makalemizde sizlere Process Injection Tekniklerini olabildiğince detaylı ve açıklayıcı şekilde anlattım." /> <link rel="canonical" href="https://fatihsensoy.com/Process-Injection-Teknikleri/" /> <meta property="og:url" content="https://fatihsensoy.com/Process-Injection-Teknikleri/" /> <meta property="og:site_name" content="Fatih Şensoy" /> <meta property="og:image" content="https://fatihsensoy.com/assets/img/process-injection-teknikleri/img/cover.jpg" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2020-04-30T19:36:00+00:00" /> <meta name="twitter:card" content="summary_large_image" /> <meta property="twitter:image" content="https://fatihsensoy.com/assets/img/process-injection-teknikleri/img/cover.jpg" /> <meta property="twitter:title" content="💉 Process Injection Teknikleri Ve Detayları" /> <script type="application/ld+json"> {"@type":"BlogPosting","image":"https://fatihsensoy.com/assets/img/process-injection-teknikleri/img/cover.jpg","headline":"💉 Process Injection Teknikleri Ve Detayları","dateModified":"2020-04-30T19:36:00+00:00","datePublished":"2020-04-30T19:36:00+00:00","url":"https://fatihsensoy.com/Process-Injection-Teknikleri/","mainEntityOfPage":{"@type":"WebPage","@id":"https://fatihsensoy.com/Process-Injection-Teknikleri/"},"author":{"@type":"Person","name":"Fatih ŞENSOY"},"description":"Bir eğitim niteliğinde olan bu makalemizde sizlere Process Injection Tekniklerini olabildiğince detaylı ve açıklayıcı şekilde anlattım.","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body data-theme="dark" class="notransition"> <script> const body = document.body; const data = body.getAttribute("data-theme"); const initTheme = (state) => { if (state === "dark") { body.setAttribute("data-theme", "dark"); } else if (state === "light") { body.removeAttribute("data-theme"); } else { localStorage.setItem("theme", data); } }; initTheme(localStorage.getItem("theme")); setTimeout(() => body.classList.remove("notransition"), 75); </script> <div class="navbar" role="navigation"> <nav class="menu"> <input type="checkbox" id="menu-trigger" class="menu-trigger" /> <label for="menu-trigger"> <span class="menu-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z" /> </svg> </span> </label> <a id="mode"> <svg class="mode-sunny" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>LIGHT</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> <svg class="mode-moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>DARK</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> </a> <div class="trigger"> <div class="trigger-container"><a class="menu-link" href="/">Anasayfa</a><a class="menu-link" href="/archive/">Arşiv</a><a class="menu-link" href="/about/">Hakkımda</a><a class="menu-link rss" href="/feed.xml"> <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 512 512" fill="#ED812E" > <title>RSS</title> <path d="M108.56,342.78a60.34,60.34,0,1,0,60.56,60.44A60.63,60.63,0,0,0,108.56,342.78Z" /> <path d="M48,186.67v86.55c52,0,101.94,15.39,138.67,52.11s52,86.56,52,138.67h86.66C325.33,312.44,199.67,186.67,48,186.67Z" /> <path d="M48,48v86.56c185.25,0,329.22,144.08,329.22,329.44H464C464,234.66,277.67,48,48,48Z" /> </svg> </a> </div> </div> </nav> </div> <div class="main_wrapper"> <div class="toc_wrapper"> <div class="toc_content"> <h2>İçerik</h2> <ul><li><a href="#process-injection-nedir">Process Injection Nedir?</a></li><li><a href="#1---remote-dll-injection">1. Remote DLL Injection</a></li><li><a href="#2-apc-dll-injection">2. APC DLL Injection</a><ul><li><a href="#örnekleyelim">Örnekleyelim</a></li></ul></li><li><a href="#3-process-hollowing">3. Process Hollowing</a></li><li><a href="#4-process-doppelgänging">4. Process Doppelgänging</a><ul><li><a href="#ayrım-noktası">Ayrım Noktası?</a></li></ul></li><li><a href="#5-atom-bombing-injection">5. Atom Bombing Injection</a></li><li><a href="#yararlanılan-kaynaklar">Yararlanılan Kaynaklar</a></li></ul> </div> </div> <div class="wrapper post"> <main class="page-content" aria-label="Content"> <article itemscope itemtype="https://schema.org/BlogPosting"></article> <header class="header"> <img src="/assets/img/process-injection-teknikleri/img/cover.jpg" alt="" style="border: 2px solid white; width: 100%;"><br><br> <div class="tags"> <span itemprop="keywords"> <a class="tag" href="/tags/#apc-dll-injection">APC DLL INJECTION</a>, <a class="tag" href="/tags/#atom-bombing-injection">ATOM BOMBING INJECTION</a>, <a class="tag" href="/tags/#process-doppelganging">PROCESS DOPPELGANGING</a>, <a class="tag" href="/tags/#process-hollowing">PROCESS HOLLOWING</a>, <a class="tag" href="/tags/#process-injection">PROCESS INJECTION</a>, <a class="tag" href="/tags/#process-injection-techniques">PROCESS INJECTION TECHNIQUES</a>, <a class="tag" href="/tags/#process-walking">PROCESS WALKING</a>, <a class="tag" href="/tags/#remote-dll-injection">REMOTE DLL INJECTION</a> </span> </div> <h1 class="header-title" itemprop="headline">💉 Process Injection Teknikleri Ve Detayları</h1> <div class="post-meta"> <time datetime="2020-04-30T19:36:00+00:00" itemprop="datePublished"> Apr 30, 2020 </time> <span itemprop="author" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">Fatih ŞENSOY</span> </span> <time hidden datetime="" itemprop="dateModified"> Apr 30, 2020 </time> <span hidden itemprop="publisher" itemtype="Person">Fatih ŞENSOY</span> <span hidden itemprop="image">/assets/img/process-injection-teknikleri/img/cover.jpg</span> <span hidden itemprop="mainEntityOfPage"><p>Hiç legal bir sistem uygulamasının sistem kaynaklarını gereğinden fazla tüketme ve olağan dışı ağ hareketleri gibi alışılmadık davranışlarda bulunduğunu farkettiniz mi? Forumlarda sık sık karşımıza çıkan “svchost.exe virüs müdür?” gibi sorulara işin farklı bir yüzünden en teknik detayları ile cevap veriyorum. Bir eğitim niteliğinde olan bu makalemizde sizlere Process Injection Tekniklerini olabildiğince detaylı ve açıklayıcı şekilde anlattım.</p> </span> </div> </header> <div class="page-content" itemprop="articleBody"> <p>Hiç legal bir sistem uygulamasının sistem kaynaklarını gereğinden fazla tüketme ve olağan dışı ağ hareketleri gibi alışılmadık davranışlarda bulunduğunu farkettiniz mi? Forumlarda sık sık karşımıza çıkan “svchost.exe virüs müdür?” gibi sorulara işin farklı bir yüzünden en teknik detayları ile cevap veriyorum. Bir eğitim niteliğinde olan bu makalemizde sizlere Process Injection Tekniklerini olabildiğince detaylı ve açıklayıcı şekilde anlattım.</p> <h2 id="process-injection-nedir"> <a href="#process-injection-nedir" class="anchor-head"></a> Process Injection Nedir? </h2> <p>Process Injection (Code Injection diye de nitelendirilir) işleminde temel amaç, zararlı bir uygulamanın veya kodun, legal bir process’in belleğine enjekte edilmesidir. Legal process’in belleğine enjekte edilecek olan nesne, bazen bir executable, bazen bir DLL, bazen de Shellcode olabilir. Enjekte işlemi tamamlandıktan sonra ise legal process bu enjekteyi çalıştırmaya zorlanır. Process Injection saldırgana bir çok avantaj sağlamakla beraber, enjeksiyon yapan saldırgan şu işlemleri yapabilir:</p> <ul> <li>Legal process’i dosya indirme, yükleme ve keyboard hareketlerini almaya zorlamak gibi işlemler yapabilir.</li> <li>API çağrılarını yönlendirebilir, API’lerin parametrelerini ele geçirebilir ve API’lerin export’larını filtreleyebilir.</li> <li>Legal process’e enjekte işlemi yaptığı için bazı güvenlik ürünlerini dolaylı yoldan baypass’layabilir.</li> <li>Ve çok daha fazlasını yapabilir. Evet, genellikle saldırganlar (malware geliştiricileri) bu teknikten sık sık faydalanır. Peki sadece saldırganlar mı yararlanır? Tabiki de hayır. Bir çok güvenlik ürünü sistem üzerinde korumayı tam olarak gerçekleştirebilmek adına enjeksiyon tekniklerini kullanmaktadır. Bunu da bir not olarak düşmekte fayda var.</li> </ul> <p>Genel bir örnek ile açıklayacak olursak, enjekte edilecek nesne (exe, DLL,Shellcode vs.) var olan bir process’e veya kendi tarafından başlatılan bir process’e enjekte olabilmesi için öncelikle enjekte olacağı process’i tanımlaması gerekir. Bunun için <strong>enumerate</strong> işlemi yapılabilir. Enumerate işlemi için birkaç Windows API’si bulunmaktadır. Bunlar;</p> <ul> <li>CreateTool32HelpSnapshot()</li> <li>Process32First()</li> <li>Process32Next()</li> </ul> <p><strong>CreateToolhelp32Snapshot()</strong> API’si, o an sistemde çalışan tüm process’lerin bir snapshot’ını alır. Daha sonra <strong>Process32First()</strong> API’si snapshot’ı alınan tüm process’ler arasından ilki hakkında bilgiler alır. <strong>Process32Next()</strong> ile de snapshot’ı alınan diğer tüm process’ler arasında tek tek gezme işlemi yapar ve hepsi hakkında bilgi toplar. Process32First() ve Process32Next() fonksiyonları sayesinde enumerate edilen process’ler hakkında alınabilen bilgilerden bazıları şunlardır;</p> <ul> <li>Executable’ın adı,</li> <li>Process ID’si (PID),</li> <li>Child Process’in ID’si, Ve daha fazla bilgiye erişilebilmektedir.</li> </ul> <p>Process32First() ve Process32Next() API’lerinin birlikte kullanımı <strong>Process Walking</strong> adında bir tekniği de temsil etmektedir. Process Walking, sistem snapshot’ındaki process’leri tek tek gezerek bilgi toplama işlemine verilen addır. Ayrıca <strong>Toolhelp32ReadProcessMemory()</strong> API’si ile de belirli bir process’in belleğini okunabilir.</p> <p>Process Walking işlemi ile malware, enjekte edilecek process’in var olup olmadığını kontrol edebilir. Var ise enjekte olabilir, yok ise hedef process’i başlatabilir. Daha sonra ise malware nesnesi (DLL, executable, Shellcode vs.) legal process’in belleğine kendisini enjekte eder ve legal process’in enjekte olan zararlıyı çalıştırması için zorlar.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-1.png" alt="Process Injection Scheme" /></p> <p>Yukarıdaki görselde bu işlem anlaşılır bir şekilde gösterilmiştir. Malware’ın user space’de çalıştığını da unutmayalım!</p> <p>Process Injection hakkında bir genelleme yaptık fakat bu ana başlık, farklı farklı teknikleri alt dallarında barındırmaktadır. Şimdi ise Process Injection tekniklerinin detaylarına değinecek ve en çok bilinen, etkili teknikleri açıklayacağız.</p> <h2 id="1---remote-dll-injection"> <a href="#1---remote-dll-injection" class="anchor-head"></a> 1. Remote DLL Injection </h2> <p>Remote DLL Injection metoduna geçmeden önce DLL hakkında kısa bir bilgi vermekte fayda var. Açılımı Dynamic Linking Library olan DLL’ler bir kod/veri kütüphanesidir. Bir çok uygulamanın ortak bir şekilde kullanması için tasarlanmıştır. DLL kullanımı daha fazla performans, daha az bellek kullanımı gibi faydalar sağlamaktadır.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-2.png" alt="Process Injection 2" /></p> <p>Yukarıdaki görselde de görüldüğü üzere MZ ve PE headerlarına sahip olmasına rağmen bir executable’ın karakteristiğine sahip olsa da tek başına çalışamamaktadır. Kısa bir şekilde DLL’den de bahsettiğimize göre Remote DLL Injection’a geçiş yapabiliriz.</p> <p>Remote DLL Injection metodu geçtiğimiz zamanlarda ve günümüzde sıkça kullanılmaktadır. Malware legal bir process’in virtual memory’sine zararlı DLL’in yolunu yazarak ve legal process’de remote thread oluşturarak bu zararlı DLL’in yüklenmesini sağlar.</p> <p>Öncelikle zararlının yapması gereken işlem Process32First, Process32Next ve CreateToolhelp32Snapshot ile az önce bahsettiğim **Process Walking **işlemlerini yapıp injekte olacağı process’i belirlemektir.</p> <p>Daha sonra ise OpenProcess API’sini kullanarak tespit ettiği hedef process’in handle’ını alır. Handle’ın tanımını Windows’un MSDN dökümanlarından alıntı yaparak açıklayacak olursak;</p> <blockquote> <p>Handle, bir nesneye yapılan başvurudur. Bir process’in bir nesneye (dosya, kayıt defteri, mutex vb.) erişebilmesi bir handle açması gerekir. Örnek vermek gerekirse bir process’in dosyaya yazma işlemi yapmak istediğini düşünelim. Process önce gerekli API’yi(WriteFile) çağırır. Daha sonra handle’ı WriteFile API’sine ileterek dosyaya yazmak için handle’ı(tanıcı da deniyor) kullanır.</p> </blockquote> <p>Process’in handle’ını alan malware, daha sonra <strong>VirtualAllocEx</strong> API’si ile bellekte allocate (yer ayırma) işlemi uygular. Daha sonra bellekte ayırdığı lokasyona <strong>WriteProcessMemory</strong> API’si ile zararlı DLL’in yolunu yazar.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-3.png" alt="Process Injection 3" /></p> <p>Daha sonra bellekteki lokasyona yolu yazılan zararlı DLL’in thread’ler tarafından çalıştırılması gerekir. Bunun için de malware, <strong>CreateRemoteThread</strong>, NtCreateThreadEx, RtlCreateUserThread gibi API’leri çağırır. Ve bu API’lerin içine DLL yükleme için kullanılan LoadLibrary API’sini yerleştirir. LoadLibrary API’sinin içerisine ise zararlı DLL’in yerini yerleştirir. Bu işlemlerden sonra Remote DLL Injection’ın pseudo kodu şu şekilde olmaktadır:</p> <p><code class="language-plaintext highlighter-rouge">CreateRemoteThread(LoadLibrary(C:\Program Files\zararli.dll))</code></p> <p>CreateRemoteThread API’si artık bir çok güvenlik ürünü tarafından izlenmektedir. Akıllı bir malware geliştiricisi bu API’yi kullanmayacaktır. Aşağıdaki görselde ise bu yöntemi kullanan Rebhip worm’una ait bir statik kod analizini görmektesiniz.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-4.png" alt="Process Injection 4" /></p> <p>Örnek bir Remote DLL Injection sonrası amacımıza ulaşabiliyoruz:</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-5.png" alt="Process Injection 5" /></p> <h2 id="2-apc-dll-injection"> <a href="#2-apc-dll-injection" class="anchor-head"></a> 2. APC DLL Injection </h2> <p>CreateRemoteThread() API’si ile Remote DLL Injection tekniğinin ardından şimdi ise APC DLL Injection tekniğini göreceğiz.</p> <p>Bu teknik, Remote DLL Injection tekniğine benzer. Fakat ayrım noktası, DLL enjekte işleminde CreateRemoteThread() API’si yerine Windows’un APC(Asynchronous Procedure Call)’sini kullanır. APC’nin kısa bir tanımını yapacak olursak;</p> <blockquote> <p>APC, belirli bir thread bağlamında eşzamansız olarak çalışan bir işlevdir. Her thread, hedef thread uyarılabilir bir duruma girdiğinde yürütülecek bir APC sırası içerir.</p> </blockquote> <p>Yani özetleyecek olursak, APC threadlerin bekleme zamanında daha az bellek kullanması için tasarlanmış bir çalışma birimidir. Bir programın birden fazla thread ile çalıştığını varsayalım. Genellikle thread’ler birbirleri ile eşzamanlı olarak çalışır. Fakat bazı veriler hazır değilse (örneğin program kullanıcıdan girdi veya onay bekliyorsa) thread, stackt’te önemli bir miktarda memory’den yer ayırdığı ve bu bellek onay gelene kadar kullanılamayacağı için thread’i bekleme durumunda memory’de tutmak pek mantıklı olmayacaktır.</p> <p>Bundan ötürü thread stack’i bellekte daha az yer kaplayan bir nesne olarak oluşturulur. Ve bu nesne, kullanıcı girişlerini alan hizmete aktarılır. Kullanıcıdan yanıt alındığında hizmet bunu nesneye koyar ve nesneyi execute birimine iletir.</p> <p>Execute hizmeti ise bir veya daha fazla thread ve görev kuyruğundan oluşur. Her çalışan thread bir görev aldığında bunu execute eder. Herhangi bir görev olmadığında ise thread bekler ve böylece bellek kullanılmaz.</p> <p>Kısa bir şekilde APC’nin de tanımını yaptığımıza göre APC DLL Injection tekniğine geçebiliriz.</p> <p>Az önce thread’in uyarılabilir(alterable) duruma geçmesinden bahsetmiştik. Bir thread aşağıdaki API’lerden birisini çağırdığında alterable duruma geçebilir:</p> <ul> <li>SleepEx();</li> <li>SignalObjectAndWait();</li> <li>MsgWaitForMultipleObjectsEx();</li> <li>WairForMultipleObjectsEx();</li> <li>WaitForSingleObjectEx();</li> </ul> <p>APC DLL Injection tekniğinde temel amaç; malware’ın hedef process’teki alterable durumda olan veya alterable duruma geçme olasılığı bulunan thread’i tanımlaması ile başlar. Daha sonra zararlı olan custom code’u QueueUserAPC() API’sini kullanarak thread’in APC kuyruğuna yerleştirir. Daha sonra ise thread, kuyruğa alınan bu zararlı custom code’un sırası geldiğinde onu çalıştırır.</p> <h3 id="örnekleyelim"> <a href="#örnekleyelim" class="anchor-head"></a> Örnekleyelim </h3> <p>Tekniği anlattık, şimdi ise kısa bir örnek verelim. Zararlı DLL’in legal iexplore.exe uygulamasını APC DLL Injection yöntemi ile enjeksiyonuna göz atacağız.</p> <p>Bu teknik, Remote DLL Injection’daki 4 adımın aynısını uygular. Yani bir handle açar, hedef process’in memory’sinde yer ayırır, malicious DLL’in yolunu ayrılan belleğe kopyalar ve LoadLibrary() API’sinin adresini belirler. Daha sonra ise hedef thread’in malicious DLL’i yüklemeye zorlanması için şu adımları izler:</p> <ol> <li>OpenThread() API’si ile hedef process’in thread’ine bir handle açar. Parametrelerinden birisi ise iexplore.exe process’inin thread’inin ID’sidir.</li> </ol> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-6.png" alt="Process Injection 6" /></p> <p>OpenThread() API’sinin dönüş değeri iexplore.exe thread’inin handle’ı olmaktadır.</p> <ol> <li>Malware process’i, Internet Explorer’ın thread’inin APC kuyruğundaki APC işlevini sıralamak için QueueUserAPC() API’sini çağırır.</li> </ol> <p>Bunun ilk parametresi malware’ın hedef thread’de yürütülmesini istediği APC işlevinin işaretçisidir. Yani APC işlevi adresi daha önce belirlenen LoadLibrary() API’sinin kendisidir. İkinci parametresi ise hedef process’in hedef thread’inin handle’ıdır. Üçüncü parametresi ise hedef process’in memory’sinde yer alana zararlı DLL’in tam yolunu içeren adrestir. Thread execute işlemi yaptığında bu adres, LoadLibrary() API’sine parametre olarak iletilmekte ve zararlı DLL execute edilmektedir.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-7.png" alt="Process Injection 7" /></p> <p>Görselde de görüldüğü üzere 3. Parametre, iexplore.exe process’inin process memory adresidir.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-8.png" alt="Process Injection 8" /></p> <p>Adrese baktığımızda ise zararlı DLL’in tam yolunu görmekteyiz.</p> <h2 id="3-process-hollowing"> <a href="#3-process-hollowing" class="anchor-head"></a> 3. Process Hollowing </h2> <p>Başka bir kod enjeksiyon tekniklerinden birisi olan Process Hollowing, legal bir process’in belleğine zararlı executable’ın enjekte edilmesini amaç edinir.</p> <p>Process Hollowing tekniği, saldırgana bir çok avantaj sağlar. En önemlisi ise güvenlik ve adli analiz araçları tarafından fark edilmemesini sağlar. Örneğin legal bir process olan iexplore.exe’ye Process Hollowing tekniği olan bir malware üzerinden konuşacak olursak, process’in yolu legal process olan iexplore.exe’nin yolunu gösterecektir. Ama iexplore.exe’nin belleğinde ise zararlı executable barınmaktadır.</p> <p>Hollowing’e sözcük bakımından genelde “kancalamak” denmektedir. Process Hollowing tekniğini gerçekleştirecek olan malware, öncelikle legal process’i suspend durumda başlatır.</p> <p>Suspend durumda başlayan legal process’in executable section’ı belleğe yüklenmiş olur. <strong>PEB</strong> (Process Environment Block) yapısı, memory’e yüklenen legal process’in tam yolunu içerir. PEB’in ImageBaseAddress kısmı ise legal process’in bellekteki executable section’ının hangi adreste olduğunun bilgisini tutar.</p> <p>Aşağıdaki görselde malware tarafından suspend durumda başlatılan svchost.exe process’ini görüyoruz. Svchost.exe process’i belleğin <strong>0x01000000</strong> adresine yüklenmiş durumda.</p> <p>Daha sonra malware, PEB.ImageBaseAddress kısmına erişmek için bellekteki PEB yapısının adresini belirler. ImageBaseAddress kısmına eriştiğinde ise legal process’in memory’deki base adresini elde eder.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-9.png" alt="Process Injection 9" /></p> <p>PEB’in tespitinden sonra malware, <strong>GetThreadContext</strong>() API’sini çağırır. GetThreadContext() API’si belirtilen thread’in içeriğini alır. Ve iki adet parametre alır. Bunlardan ilki thread’in handle’ıdır. İkinci parametre ise yapının CONTEXT adındaki pointer’ıdır.</p> <p>Malware ilk parametreye suspend edilen thread’in handle’ını, ikinci parametreye ise CONTEXT yapısının pointer’ını geçer. API çağrısından sonra CONTEXT yapısı, suspend edilen thread’in bağlamı (kaynağı) ile doldurulur.</p> <p>Bu CONTEXT yapısı artık askıya alınan register durumlarını içerir. Malware daha sonra PEB yapısının işaretçisini içeren CONTEXT._EBX alanını okur. PEB adresi belirlendikten sonra ise ImageBaseAddress kısmını okuduğunu söylemiştik. Bunu yapmasının amacı da legal executable’ın base adresini belirlemekti.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-10.png" alt="Process Injection 10" /></p> <p>Yukarıdaki görselde process belleğinin okunma işlemi görülmektedir.</p> <p>PEB pointer’ını tespit etmek için diğer bir yöntemin NtQueryInformationProcess API’si olduğunu söylemekte de fayda var. Hedef legal process’in base adresini belirleyen malware, legal process’in executable section’ını (çalıştırılabilir kısmını) bellekten ayırır (deallocate eder). Bunu da NtUnMapViewofSection() API’si ile gerçekleştirir.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-11.png" alt="Process Injection 11" /></p> <p>Yukarıdaki görselde ilk parametrenin svchost.exe legal process’inin handle’ı, ikinci parametrenin ise legal process’in base adresi olduğunu görüyorsunuz. Bu işlemden sonra legal process’in executable section’ı bellekten ayrılmış, yani unmap edilmiş oluyor. Legal process’in memory’sinden boşaltılan, deallocate edilen kısımda ise RWX izinlerine sahip yeni bir kısım allocate edilir.</p> <p>Yeni bellek adresi önceki process ile aynı adreste veya farklı bir adreste allocate edilebilir. Yukarıdaki görselde VirtualAllocEx() API’sini memory’de <strong>0x00400000</strong> adresinde ayırma yapması için çağırdığı görülmektedir.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-12.png" alt="Process Injection 12" /></p> <p>Yukarıdaki görselde 0x00400000 adresinde allocate edilen bellek alanını görmektesiniz.</p> <p>Bellekte istediği lokasyondan <strong>RWX</strong> izinlerinde yer ayırma işlemi yapan malware, <strong>WriteProcessMemory</strong> API()’sini kullanarak yürütülebilir dosyayı ve section’larını 0x00400000 adresindeki ayrılan konuma kopyalar. Aşağıdaki görselde bu durum görülmektedir.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-13.png" alt="Process Injection 13" /></p> <p>Bu işlemlerden sonra malware, legal process’in PEB.ImageBaseAddress kısmına, artık zararlı içerikle dolu olan 0x00400000 adresini yazar.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-14.png" alt="Process Injection 14" /></p> <p>Yukarıdaki görselde de artık legal process’in PEB.ImageBaseAdress kısmında yazılı olan değerin 0x01000000’den artık içinde zararlı executable’ı barındıran 0x00400000 adresinin yazılı olduğunu görüyoruz. Yani kısacası malware, suspend halde olan legal process’in start adresini, bellekte legal process’in executable kısmına enjekte edilen zararlının start adresi ile değiştiriyor.</p> <p>Bu işlemden sonra artık suspend durumda olan process’in thread’i zararlı kısma işaret etmektedir. Artık saldırganın yapması gereken tek şey suspend edilen thread’in **ResumeThread() **API’si ile suspend durumdan resume durumuna geçmesini sağlayıp enjekte edilen kodu (ya da executable’ı) çalıştırmasını izlemektir.</p> <p>Ayrıca malware, zararlı executable’ı hedef işleme enjekte etmek için VirtualAllocEx() ve WriteProcessMemory() tekniklerinden kaçınmak amacıyla <strong>NtMapViewSection</strong>() API’sini kullanabilmektedir. Bu API’de Process Hollowing tekniğinde kullanılan API’lerden birisidir.</p> <h2 id="4-process-doppelgänging"> <a href="#4-process-doppelgänging" class="anchor-head"></a> 4. Process Doppelgänging </h2> <p>Popüler Code Injection tekniklerinden birisi olan Process Doppelgänging, ilk olarak 2017 yılında BlackHat’te enSilo şirketinde çalışan 2 güvenlik araştırmacısı tarafından açıklandı.</p> <p>Process Doppelgänging Windows 10 dahil olmak üzere tüm Windows sürümlerinde başarıyla çalışmasından dolayı büyük bir öneme sahiptir. Process Hollowing ile benzerlik gösterse, Process Hollowing’den kesin olarak ayrılan yönleri vardır.</p> <p>Process Doppelgänging, ilk ortaya çıktığı zamanlarda bir çok AV ürünü tarafından zor tespit edildiği için malware’lar tarafından sıkça kullanılmıştır..</p> <h3 id="ayrım-noktası"> <a href="#ayrım-noktası" class="anchor-head"></a> Ayrım Noktası? </h3> <p>Process Hollowing önce hedef işlemi başlatır, daha sonra unmap işlemini yapar ve zararlı kodu enjekte eder. Process Doppelgänging ise process başlamadan önce image’ın üzerine zararlı kodu yazmaktadır. En önemli ayrım noktaları ise bu tekniktir.</p> <p>Process Doppelgänging, Windows NTFS işlemlerini kullanmaktadır. TFS dosyasının işlemlerine(oluşturma, silme, değiştirme) dayanan bir tekniktir. İşlemsel NTFS, diğer adıyla TxF, process’leri NTFS dosya sistemine entegre eder. Process Doppelgänging, kötü amaçlı kodu veya yazılımı gizlemek için belirli olan bu özellikleri kullanır. Process’in çalışma esnasında bir dosya oluşturduğumuzu ve içine yazma işlemi yaptığımızı düşünelim. Windows’un yapısı gereği process dosya üzerindeki işlemini bitirmeden veya kapatmadan, dosya diskte görünmeyecektir. İşte Process Doppelgänging’in avantajlarından birisi de bu yöntemdir.</p> <p>Process Doppelgänging için NTFS işlemlerinde <strong>4 adet basamak</strong> vardır. Bunları şu şekilde sıralayabilir ve açıklayabiliriz:</p> <p><strong>Transact</strong>: Bu aşamada legal process işlenir ve üzerine malicious uygulama yazılır. Bu işlemin alt aşamaları bulunmaktadır:</p> <p>İlk olarak CreateTransaction() API’si kullanılarak yeni transaction(işlem) oluşturulur. CreateFileTransacted() API’si ile işlem görmüş bir handle elde edilir. Bu handle gereken tüm dosya işlemleri için kullanılabilir. Legal dosyanın üzerine WriteFile() API’si ile malicious içerik yazılır.</p> <p><strong>Load</strong>: Bu aşamada ise 1. Aşamada üzerine yazma işlemi yapılarak değiştirilen dosyadan bir memory bölümü oluşturulur. NtCreateSection() API’si ile işlem yapılan dosyadan bir bir bölüm oluşturulur. Bu bölüm, zararlı dosyaya işaret edecektir.</p> <p><strong>Rollback</strong>: Bu aşamada ise yapılan tüm değişiklikler geri alınır. Orijinal dosyayı diskte bırakır. RollbackTransaction() API’si ile bu işlemi gerçekleştirmektedir.</p> <p><strong>Execution</strong>: Bu kısım Process Doppelgänging’in nasıl kaçamaklı, sahte ricatlı (geri çekilmeli) bir teknik olduğunu bize açıklayacaktır. İlk aşamadan itibaren, daha önce açılan bir process’i execute edebilecek, Windows XP’den beridir süregelen eski bir komut bulunmaktadır.</p> <ul> <li>İlk olarak process ve threadler, <strong>NtCreateProcessEx</strong>() ve <strong>NtCreateThreadEx</strong>() API’leri kullanılarak oluşturulur.</li> <li>Process parametreleri <strong>RtlCreateProcessParameters</strong>() API’si ile oluşturulur.</li> <li><strong>VirtualAllocEx</strong>() API’si ve önceden kullanılan parametreler kullanılarak boş alan ayrılır.</li> <li>Daha sonra ise <strong>NtResumeThread</strong>() API’si kullanılarak ayrı bir process başlatılır.</li> </ul> <p>Sonuç olarak, dosya içeriği geri alındıktan sonra bile process enjekte edilmiş bir halde başlayabilir. Bu nedenle de bir çok AV ürünü tarafından hiçbir sorun yokmuş gibi gözükecektir.</p> <p>Örneğin, <strong>mimikatz</strong> normal bir şekilde başlatıldığında AV sistemleri bunu hemen tespit edebildiler. Fakat legal bir process’e, Process Doppelgänging tekniği ile enjekte edilip başladığında AV sistemleri bunu tespit edemedi.</p> <p>Özet olarak yapmamız gereken şey, zararlı içeriğin tam yolunu vermek iken rollback işleminden sonra PE içeriğine sahip bir bölümü parametre olarak alan Zw/NtCreateProcessEx() API’si vardır. Bu API’yi kullanarak dosyasız bir şekilde injection yapmış gibi oluruz ve işletim sistemi sadece dosya kapandığında değişikleri farkedeceği için bunu algılayamaz.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-15.png" alt="Process Injection 15" /></p> <p>Yukarıdaki görselde <strong>NtCreateProcessEx</strong>() API’sinin yapısını görmektesiniz.</p> <p>Bu teknik tamamen gizli değildir, ve tespiti de snapshot yöntemleri kullanılarak ve karşılaştırmalar ile yapılabilir. Sonuçta Remote bir thread oluşturduğu için AV sistemlerini tetikleyebilir.</p> <p>2017 yılında ortaya çıkmış bir teknik olarak günümüzdeki AV sistemlerinin bu tekniği tespit edebileceğini söyleyebiliriz.</p> <h2 id="5-atom-bombing-injection"> <a href="#5-atom-bombing-injection" class="anchor-head"></a> 5. Atom Bombing Injection </h2> <p>Process Doppelgänging kod enjeksiyon tekniğinin ardından Atom Bombing Injection tekniğine geliyoruz. Atom Bombing tekniğini, yine adını az önceki Process Doppelgänging tekniğinden de hatırlayacağınız enSilo şirketinde çalışan güvenlik araştırmacıları bulmuştur.</p> <p>Atom Bombing tekniği Windows’un tüm sürümlerinde çalışmaktadır. Bir bug veya zafiyet değildir, aksine Windows’un doğası gereği ortaya çıkan bir tekniktir. Bundan dolayı da herhangi bir yama söz konusu değildir.</p> <p>Ortaya çıkmasından sonra artık AV ürünleri tarafından tespiti de yapılabilmektedir. Bu teknik ise 2018 yılında ortaya çıkmıştır.</p> <p>Atom Bombing, adını Windows’un atom tablolarından almaktadır. Atom tabloları, process’ler arasında paylaşılan sistem belleğini kullanarak veri paylaşımı/değişimi gibi işlemleri gerçekleştirir. Atom tablolarını Windows şu şekilde tanımlamaktadır:</p> <blockquote> <p>“Atom tablosu, strings’leri ve karşılık gelen tanımlayıcıları saklayan sistem tanımlı bir tablodur. Bir uygulama, bir string’i atom tablosuna yerleştirir ve o string’e erişmek için 16 bitlik bir tam sayı alır. Atom tablosuna yerleştirilen bu string’e atom adı verilir.”</p> </blockquote> <p>Bu açıklamadan yola çıkarak bu tekniğin arkasında yatan planı da az çok kurguluyor gibiyiz. Malware process’i legal bir string yerine zararlı kodu atom olarak oluşturuyor ve hedef olan legal process’in bu oluşturulan zararlı atom’u yükleyerek çalıştırmasını sağlıyor.</p> <p><img src="/assets/img/process-injection-teknikleri/img/procinj-16.jpg" alt="Process Injection 16" /></p> <p>Yukarıdaki görselde Atom Bombing tekniğinin çalışma yapısı gösterilmiştir. Atom Bombing tekniğinin nasıl gerçekleştiğini anlamak için teknik olarak açıklayalım:</p> <p>Malware (zararlı process), GlobalAddAtom() ile zararlı kodu string biçiminde atom tablosuna yerleştirir. Atom tablosu sistemde çalışan her process tarafından erişilebilir durumdadır.</p> <p><strong>APC</strong>(Asynchronous Procedure Call) kullanarak, <strong>GlobalGetAtomName</strong>() ile zararlı kodu atom tablosundan legal process’in bellek alanına kopyalar. APC kullanıldığı için bu teknik alterable durumda olan herhangi bir process’in thread’i tarafından yapılabilir.</p> <p>Daha sonrasında ise sistemi yeni bir executable bellek allocate etmeye zorlar. Bellek allocate işleminden sonra zararlı kodu ayrılan bellek alanına kopyalar ve çalıştırır.</p> <p>Yukarıdaki adımlarda da teknik detayını açıkladık. Bu tekniğin hakkında önemli olan bazı kısımlar mevcuttur.</p> <p>Atom Bombing, bir Privilege Escalation(yetki yükseltme) sağlamaz. AV ürünleri tarafından beyaz listede olan process’leri hedef alarak bypass yapar.</p> <p>Process’in özel verilerine erişmeye imkan sağlar. Yani belirli bir process’i hedef aldığınızda, (Web Browser gibi), web içeriğini değiştirebilir, tarayıcıdaki parolalara erişebilirsiniz. Ekran görüntüsü alabilirsiniz. Bu tamamen hangi process’i hedef aldığınıza bağlı olmak ile birlikte saldırgana çok geniş imkanlar sunmaktadır.</p> <p>Gerçek bir örnek vermek gerekirse Dridex bankacılık trojanı, bu teknik ortaya çıktıktan sonra Atom Bombing’i kullanmaya başlamıştır. Bilin bakalım neden 🙂</p> <p>Atom Bombing tekniğinin APC’yi kullandığını tekrar hatırlayalım. APC hakkında çok az bilgi mevcut. Ama örneklendirmek gerekirse normal işlevinde ilerleyen başka bir process’in thread’ini zararlı kodu çalıştırmak için Malware’lar tarafından kullanılmaktadır.</p> <p>Sizlere en çok ses getiren, ilginç ve işe yarar Process Injection tekniklerini anlattım. Artık svchost.exe’nin legal bir sistem uygulaması olduğunu ve zararlı yazılımların da uğrak yeri olduğunu biliyoruz 🙂</p> <p>Başka bir teknik makalede görüşmek üzere…</p> <h2 id="yararlanılan-kaynaklar"> <a href="#yararlanılan-kaynaklar" class="anchor-head"></a> Yararlanılan Kaynaklar </h2> <p>[1] https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process</p> <p>[2] https://www.deepinstinct.com/2019/09/15/malware-evasion-techniques-part-1-process-injection-and-manipulation</p> <p>[3] https://kaganisildak.com/2019/02/10/process-doppelganging/</p> </div> </article> <div class="comments"> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_shortname = 'fatihsensoy'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> </div> </main> <nav class="post-nav"> <a class="post-nav-item post-nav-prev" href="/Pratik-WireShark-Filtreleri/" > <div class="nav-arrow">Previous</div> <span class="post-title">Pratik Wireshark 🦈 Filtreleri</span> </a> <a class="post-nav-item post-nav-next" href="/perdenin-ardindakiler-0x01/"> <div class="nav-arrow">Next</div> <span class="post-title">Perdenin Ardındakiler 0x01 - Android Zararlısını Işığa Kavuşturmak</span> </a> </nav> <footer class="footer"> <a class="footer_item" href="mailto:iletisim@fatihsensoy.com">Contact Me 📧</a> <a class="footer_item" href="/feed.xml">RSS</a> <small class="footer_copyright"> <span class="footer_item">Fatih Şensoy &copy;2021</span> </small> </footer> <script src="/assets/js/main.js" defer="defer"></script> <!-- Global site tag (gtag.js) - Google Analytics --> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-155173124-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-155173124-1'); </script> </div> </div> </body> </html>
